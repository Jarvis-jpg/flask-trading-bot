//@version=6
strategy("JARVIS OPTIMIZED - QUALITY OVER QUANTITY",
         shorttitle="JARVIS_OPT",
         overlay=true,
         default_qty_type=strategy.percent_of_equity,
         default_qty_value=4.0,
         currency=currency.USD,
         initial_capital=25000,
         commission_type=strategy.commission.percent,
         commission_value=0.1,
         slippage=2)

// Target: 3-4 Quality Trades/Day | 60-65% Win Rate | 2.5:1 Risk-Reward | 4.0% Risk Per Trade
// Based on: Enhanced EMA System + Premium Sessions + Better Confirmation
// Compatible with: Advanced ML Backend & Risk Management System

// Define input groups
g_general = "General Settings"
g_strategy = "Strategy Parameters"
g_sessions = "Session Settings"

// Input Parameters - OPTIMIZED FOR QUALITY
webhook_url = input.string("https://jarvis-quant-sys.onrender.com/webhook", "Webhook URL", group=g_general)
risk_percent = input.float(4.0, "Risk Per Trade (%)", minval=1.0, maxval=5.0, step=0.1, group=g_general)
risk_reward_ratio = input.float(2.5, "Risk:Reward Ratio", minval=2.0, maxval=3.5, step=0.1, group=g_general)

// Balanced EMAs for Quality Signals
ema_fast = input.int(21, "Fast EMA", minval=15, maxval=25, group=g_strategy)
ema_slow = input.int(50, "Slow EMA", minval=45, maxval=55, group=g_strategy)

// Balanced RSI Filter (Quality over Quantity)
rsi_period = input.int(14, "RSI Period", minval=12, maxval=16, group=g_strategy)
rsi_min = input.int(40, "RSI Minimum for Longs", minval=35, maxval=45, group=g_strategy)
rsi_max = input.int(75, "RSI Maximum for Longs", minval=70, maxval=80, group=g_strategy)
rsi_max_short = input.int(60, "RSI Maximum for Shorts", minval=55, maxval=65, group=g_strategy)
rsi_min_short = input.int(25, "RSI Minimum for Shorts", minval=20, maxval=30, group=g_strategy)

enable_session_filter = input.bool(true, "Enable Premium Sessions Only", group=g_sessions)
enable_overlap_boost = input.bool(true, "Prioritize London/NY Overlap", group=g_sessions)

// Create table variable
var t = table.new(position.top_right, 2, 5, bgcolor=color.white, border_width=1)

// 1. Balanced EMA System for Quality Signals
ema_21 = ta.ema(close, ema_fast)
ema_50 = ta.ema(close, ema_slow)

// 2. RSI for Momentum (Balanced Filter)
rsi = ta.rsi(close, rsi_period)

// 3. ATR for Position Sizing & Volatility
atr = ta.atr(14)

// 4. MACD for Additional Confirmation
[macd_line, signal_line, _] = ta.macd(close, 12, 26, 9)

// Define premium trading sessions
london_session = not na(time(timeframe.period, "0800-1700", "GMT"))
ny_session = not na(time(timeframe.period, "1300-2200", "GMT"))
overlap_session = not na(time(timeframe.period, "1300-1700", "GMT"))

// Session quality assessment
session_quality = 0
if overlap_session and enable_overlap_boost
    session_quality := 3  // Highest quality: London/NY overlap
else if (london_session or ny_session) and enable_session_filter
    session_quality := 2  // Good quality: Major sessions
else if not enable_session_filter
    session_quality := 1  // Allow all sessions if filter disabled
else
    session_quality := 0  // Skip low-quality sessions

session_ok = session_quality >= 1

// Component 1: EMA Trend Alignment
ema_bullish = ema_21 > ema_50 and close > ema_21
ema_bearish = ema_21 < ema_50 and close < ema_21

// Component 2: Balanced RSI Filter
rsi_ok_long = rsi >= rsi_min and rsi <= rsi_max
rsi_ok_short = rsi <= rsi_max_short and rsi >= rsi_min_short

// Component 3: Enhanced Momentum
momentum_up = close > close[1] and close[1] > close[2]
momentum_down = close < close[1] and close[1] < close[2]

// Component 4: MACD Confirmation
macd_bullish = macd_line > signal_line and macd_line > macd_line[1]
macd_bearish = macd_line < signal_line and macd_line < macd_line[1]

// Signal Generation
buy_signal = ema_bullish and rsi_ok_long and momentum_up and macd_bullish and session_ok
sell_signal = ema_bearish and rsi_ok_short and momentum_down and macd_bearish and session_ok

// Helper Functions
convert_symbol_for_jarvis() =>
    ticker = syminfo.ticker
    symbol_converted =
      ticker == "EURUSD" ? "EUR_USD" :
      ticker == "GBPUSD" ? "GBP_USD" :
      ticker == "USDJPY" ? "USD_JPY" :
      ticker == "USDCHF" ? "USD_CHF" :
      ticker == "AUDUSD" ? "AUD_USD" :
      ticker == "USDCAD" ? "USD_CAD" :
      ticker == "NZDUSD" ? "NZD_USD" :
      ticker == "EURGBP" ? "EUR_GBP" : ticker
    symbol_converted

// Calculate position size based on ATR stop
calculate_position_size(entry_price, stop_loss_price) =>
    risk_amount = strategy.equity * (risk_percent / 100)
    price_diff = math.abs(entry_price - stop_loss_price)
    position_size = risk_amount / price_diff
    position_size

// Enhanced ATR-based stops (2.0x ATR for quality trading)
calculate_levels(is_buy, entry_price) =>
    stop_distance = atr * 2.0
    var float stop_loss = na
    var float take_profit = na
    
    if is_buy
        stop_loss := entry_price - stop_distance
        take_profit := entry_price + (stop_distance * risk_reward_ratio)
    else
        stop_loss := entry_price + stop_distance
        take_profit := entry_price - (stop_distance * risk_reward_ratio)
    
    [stop_loss, take_profit]

// Execute BUY trades
if buy_signal
    [sl, tp] = calculate_levels(true, close)
    pos_size = calculate_position_size(close, sl)
    
    // Create webhook alert
    jarvis_symbol = convert_symbol_for_jarvis()
    alert_message = "{\""+"symbol"+"\": \""+ jarvis_symbol +
                   "\", \""+"action"+"\": \""+"BUY"+"\"" +
                   ", \""+"price"+"\": "+ str.tostring(close, "#.#####") +
                   ", \""+"strategy"+"\": \""+"JARVIS_OPTIMIZED"+"\"" +
                   ", \""+"stop_loss"+"\": "+ str.tostring(sl, "#.#####") +
                   ", \""+"take_profit"+"\": "+ str.tostring(tp, "#.#####") + "}"
    
    strategy.entry("LONG", strategy.long, qty=pos_size)
    strategy.exit("LONG_EXIT", "LONG", stop=sl, limit=tp)
    alert(alert_message, alert.freq_once_per_bar)

// Execute SELL trades
if sell_signal
    [sl, tp] = calculate_levels(false, close)
    pos_size = calculate_position_size(close, sl)
    
    // Create webhook alert
    jarvis_symbol = convert_symbol_for_jarvis()
    alert_message = "{\""+"symbol"+"\": \""+ jarvis_symbol +
                   "\", \""+"action"+"\": \""+"SELL"+"\"" +
                   ", \""+"price"+"\": "+ str.tostring(close, "#.#####") +
                   ", \""+"strategy"+"\": \""+"JARVIS_OPTIMIZED"+"\"" +
                   ", \""+"stop_loss"+"\": "+ str.tostring(sl, "#.#####") +
                   ", \""+"take_profit"+"\": "+ str.tostring(tp, "#.#####") + "}"
    
    strategy.entry("SHORT", strategy.short, qty=pos_size)
    strategy.exit("SHORT_EXIT", "SHORT", stop=sl, limit=tp)
    alert(alert_message, alert.freq_once_per_bar)

// Plotting
plot(ema_21, "EMA 21", color=color.blue, linewidth=2)
plot(ema_50, "EMA 50", color=color.red, linewidth=2)

// Signal markers with session quality
plotshape(buy_signal, "Buy", shape.triangleup, location.belowbar,
          color=session_quality == 3 ? color.lime : color.green, size=size.normal)
plotshape(sell_signal, "Sell", shape.triangledown, location.abovebar,
          color=session_quality == 3 ? color.red : color.maroon, size=size.normal)

// Session quality background
session_color = session_quality == 3 ? color.new(color.green, 95) : session_quality == 2 ? color.new(color.yellow, 95) : na
bgcolor(session_color)

// Statistics Table
if barstate.islast
    win_rate = strategy.closedtrades > 0 ? (strategy.wintrades / strategy.closedtrades) * 100 : 0.0
    
    table.cell(t, 0, 0, "JARVIS OPTIMIZED", text_color=color.black, text_size=size.small)
    table.cell(t, 1, 0, "VALUE", text_color=color.black, text_size=size.small)
    
    table.cell(t, 0, 1, "Total Trades", text_color=color.black)
    table.cell(t, 1, 1, str.tostring(strategy.closedtrades), text_color=color.black)
    
    table.cell(t, 0, 2, "Win Rate", text_color=color.black)
    table.cell(t, 1, 2, str.tostring(win_rate, "#.#") + "%", text_color=win_rate >= 60 ? color.green : color.red)
    
    table.cell(t, 0, 3, "Net Profit", text_color=color.black)
    table.cell(t, 1, 3, str.tostring(strategy.netprofit, "#.##"), text_color=strategy.netprofit > 0 ? color.green : color.red)
    
    table.cell(t, 0, 4, "Risk/Trade", text_color=color.black)
    table.cell(t, 1, 4, str.tostring(risk_percent, "#.#") + "%", text_color=color.black)
